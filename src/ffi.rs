/* automatically generated by rust-bindgen */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub type Clp_Simplex = ::std::os::raw::c_void;
pub type clp_callback = ::std::option::Option<
    unsafe extern "C" fn(
        model: *mut Clp_Simplex,
        msgno: ::std::os::raw::c_int,
        ndouble: ::std::os::raw::c_int,
        dvec: *const f64,
        nint: ::std::os::raw::c_int,
        ivec: *const ::std::os::raw::c_int,
        nchar: ::std::os::raw::c_int,
        cvec: *mut *mut ::std::os::raw::c_char,
    ),
>;
pub type Sbb_Model = ::std::os::raw::c_void;
pub type Cbc_Model = ::std::os::raw::c_void;
#[doc = " typedef for user call back."]
#[doc = "The cvec are constructed so don\'t need to be const"]
pub type sbb_callback = ::std::option::Option<
    unsafe extern "C" fn(
        model: *mut Sbb_Model,
        msgno: ::std::os::raw::c_int,
        ndouble: ::std::os::raw::c_int,
        dvec: *const f64,
        nint: ::std::os::raw::c_int,
        ivec: *const ::std::os::raw::c_int,
        nchar: ::std::os::raw::c_int,
        cvec: *mut *mut ::std::os::raw::c_char,
    ),
>;
pub type cbc_callback = ::std::option::Option<
    unsafe extern "C" fn(
        model: *mut Cbc_Model,
        msgno: ::std::os::raw::c_int,
        ndouble: ::std::os::raw::c_int,
        dvec: *const f64,
        nint: ::std::os::raw::c_int,
        ivec: *const ::std::os::raw::c_int,
        nchar: ::std::os::raw::c_int,
        cvec: *mut *mut ::std::os::raw::c_char,
    ),
>;
#[doc = " typedef for cbc cut callback osiSolver needs to be an OsiSolverInterface object,"]
#[doc = " osiCuts is an OsiCuts object and appdata is a pointer that will be passed to the cut"]
#[doc = " generation, you can use it to point to a data structure with information about the original problem,"]
#[doc = " for instance"]
pub type cbc_cut_callback = ::std::option::Option<
    unsafe extern "C" fn(
        osiSolver: *mut ::std::os::raw::c_void,
        osiCuts: *mut ::std::os::raw::c_void,
        appdata: *mut ::std::os::raw::c_void,
    ),
>;
pub type CoinBigIndex = ::std::os::raw::c_int;
pub type Clp_Solve = ::std::os::raw::c_void;
extern "C" {
    #[doc = " Clp library version number as string."]
    #[link_name = "\u{1}_Clp_Version"]
    pub fn Clp_Version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Major number of Clp library version."]
    #[link_name = "\u{1}_Clp_VersionMajor"]
    pub fn Clp_VersionMajor() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Minor number of Clp library version."]
    #[link_name = "\u{1}_Clp_VersionMinor"]
    pub fn Clp_VersionMinor() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release number of Clp library version."]
    #[link_name = "\u{1}_Clp_VersionRelease"]
    pub fn Clp_VersionRelease() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Default constructor"]
    #[link_name = "\u{1}_Clp_newModel"]
    pub fn Clp_newModel() -> *mut Clp_Simplex;
}
extern "C" {
    #[doc = " Destructor"]
    #[link_name = "\u{1}_Clp_deleteModel"]
    pub fn Clp_deleteModel(model: *mut Clp_Simplex);
}
extern "C" {
    #[doc = " Default constructor"]
    #[link_name = "\u{1}_ClpSolve_new"]
    pub fn ClpSolve_new() -> *mut Clp_Solve;
}
extern "C" {
    #[doc = " Destructor"]
    #[link_name = "\u{1}_ClpSolve_delete"]
    pub fn ClpSolve_delete(solve: *mut Clp_Solve);
}
extern "C" {
    #[doc = " Loads a problem (the constraints on the"]
    #[doc = "rows are given by lower and upper bounds). If a pointer is NULL then the"]
    #[doc = "following values are the default:"]
    #[doc = "<ul>"]
    #[doc = "<li> <code>colub</code>: all columns have upper bound infinity"]
    #[doc = "<li> <code>collb</code>: all columns have lower bound 0"]
    #[doc = "<li> <code>rowub</code>: all rows have upper bound infinity"]
    #[doc = "<li> <code>rowlb</code>: all rows have lower bound -infinity"]
    #[doc = "<li> <code>obj</code>: all variables have 0 objective coefficient"]
    #[doc = "</ul>"]
    #[doc = "given in a standard column major ordered format (without gaps)."]
    #[link_name = "\u{1}_Clp_loadProblem"]
    pub fn Clp_loadProblem(
        model: *mut Clp_Simplex,
        numcols: ::std::os::raw::c_int,
        numrows: ::std::os::raw::c_int,
        start: *const CoinBigIndex,
        index: *const ::std::os::raw::c_int,
        value: *const f64,
        collb: *const f64,
        colub: *const f64,
        obj: *const f64,
        rowlb: *const f64,
        rowub: *const f64,
    );
}
extern "C" {
    #[link_name = "\u{1}_Clp_loadQuadraticObjective"]
    pub fn Clp_loadQuadraticObjective(
        model: *mut Clp_Simplex,
        numberColumns: ::std::os::raw::c_int,
        start: *const CoinBigIndex,
        column: *const ::std::os::raw::c_int,
        element: *const f64,
    );
}
extern "C" {
    #[doc = " Read an mps file from the given filename"]
    #[link_name = "\u{1}_Clp_readMps"]
    pub fn Clp_readMps(
        model: *mut Clp_Simplex,
        filename: *const ::std::os::raw::c_char,
        keepNames: ::std::os::raw::c_int,
        ignoreErrors: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write an mps file to the given filename */"]
    #[doc = "Number across is 1 or 2."]
    #[doc = "Use objSense = -1D to flip the objective function around."]
    #[link_name = "\u{1}_Clp_writeMps"]
    pub fn Clp_writeMps(
        model: *mut Clp_Simplex,
        filename: *const ::std::os::raw::c_char,
        formatType: ::std::os::raw::c_int,
        numberAcross: ::std::os::raw::c_int,
        objSense: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy in integer informations"]
    #[link_name = "\u{1}_Clp_copyInIntegerInformation"]
    pub fn Clp_copyInIntegerInformation(
        model: *mut Clp_Simplex,
        information: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Drop integer informations"]
    #[link_name = "\u{1}_Clp_deleteIntegerInformation"]
    pub fn Clp_deleteIntegerInformation(model: *mut Clp_Simplex);
}
extern "C" {
    #[doc = " Resizes rim part of model"]
    #[link_name = "\u{1}_Clp_resize"]
    pub fn Clp_resize(
        model: *mut Clp_Simplex,
        newNumberRows: ::std::os::raw::c_int,
        newNumberColumns: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Deletes rows"]
    #[link_name = "\u{1}_Clp_deleteRows"]
    pub fn Clp_deleteRows(
        model: *mut Clp_Simplex,
        number: ::std::os::raw::c_int,
        which: *const ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Add rows"]
    #[link_name = "\u{1}_Clp_addRows"]
    pub fn Clp_addRows(
        model: *mut Clp_Simplex,
        number: ::std::os::raw::c_int,
        rowLower: *const f64,
        rowUpper: *const f64,
        rowStarts: *const CoinBigIndex,
        columns: *const ::std::os::raw::c_int,
        elements: *const f64,
    );
}
extern "C" {
    #[doc = " Deletes columns"]
    #[link_name = "\u{1}_Clp_deleteColumns"]
    pub fn Clp_deleteColumns(
        model: *mut Clp_Simplex,
        number: ::std::os::raw::c_int,
        which: *const ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Add columns"]
    #[link_name = "\u{1}_Clp_addColumns"]
    pub fn Clp_addColumns(
        model: *mut Clp_Simplex,
        number: ::std::os::raw::c_int,
        columnLower: *const f64,
        columnUpper: *const f64,
        objective: *const f64,
        columnStarts: *const CoinBigIndex,
        rows: *const ::std::os::raw::c_int,
        elements: *const f64,
    );
}
extern "C" {
    #[doc = " Change row lower bounds"]
    #[link_name = "\u{1}_Clp_chgRowLower"]
    pub fn Clp_chgRowLower(model: *mut Clp_Simplex, rowLower: *const f64);
}
extern "C" {
    #[doc = " Change row upper bounds"]
    #[link_name = "\u{1}_Clp_chgRowUpper"]
    pub fn Clp_chgRowUpper(model: *mut Clp_Simplex, rowUpper: *const f64);
}
extern "C" {
    #[doc = " Change column lower bounds"]
    #[link_name = "\u{1}_Clp_chgColumnLower"]
    pub fn Clp_chgColumnLower(model: *mut Clp_Simplex, columnLower: *const f64);
}
extern "C" {
    #[doc = " Change column upper bounds"]
    #[link_name = "\u{1}_Clp_chgColumnUpper"]
    pub fn Clp_chgColumnUpper(model: *mut Clp_Simplex, columnUpper: *const f64);
}
extern "C" {
    #[doc = " Change objective coefficients"]
    #[link_name = "\u{1}_Clp_chgObjCoefficients"]
    pub fn Clp_chgObjCoefficients(model: *mut Clp_Simplex, objIn: *const f64);
}
extern "C" {
    #[doc = " Change matrix coefficients"]
    #[link_name = "\u{1}_Clp_modifyCoefficient"]
    pub fn Clp_modifyCoefficient(
        model: *mut Clp_Simplex,
        row: ::std::os::raw::c_int,
        column: ::std::os::raw::c_int,
        newElement: f64,
        keepZero: bool,
    );
}
extern "C" {
    #[doc = " Drops names - makes lengthnames 0 and names empty"]
    #[link_name = "\u{1}_Clp_dropNames"]
    pub fn Clp_dropNames(model: *mut Clp_Simplex);
}
extern "C" {
    #[doc = " Copies in names"]
    #[link_name = "\u{1}_Clp_copyNames"]
    pub fn Clp_copyNames(
        model: *mut Clp_Simplex,
        rowNames: *const *const ::std::os::raw::c_char,
        columnNames: *const *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Number of rows"]
    #[link_name = "\u{1}_Clp_numberRows"]
    pub fn Clp_numberRows(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Number of columns"]
    #[link_name = "\u{1}_Clp_numberColumns"]
    pub fn Clp_numberColumns(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Primal tolerance to use"]
    #[link_name = "\u{1}_Clp_primalTolerance"]
    pub fn Clp_primalTolerance(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_Clp_setPrimalTolerance"]
    pub fn Clp_setPrimalTolerance(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Dual tolerance to use"]
    #[link_name = "\u{1}_Clp_dualTolerance"]
    pub fn Clp_dualTolerance(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_Clp_setDualTolerance"]
    pub fn Clp_setDualTolerance(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Dual objective limit"]
    #[link_name = "\u{1}_Clp_dualObjectiveLimit"]
    pub fn Clp_dualObjectiveLimit(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_Clp_setDualObjectiveLimit"]
    pub fn Clp_setDualObjectiveLimit(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Objective offset"]
    #[link_name = "\u{1}_Clp_objectiveOffset"]
    pub fn Clp_objectiveOffset(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_Clp_setObjectiveOffset"]
    pub fn Clp_setObjectiveOffset(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Fills in array with problem name"]
    #[link_name = "\u{1}_Clp_problemName"]
    pub fn Clp_problemName(
        model: *mut Clp_Simplex,
        maxNumberCharacters: ::std::os::raw::c_int,
        array: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_Clp_setProblemName"]
    pub fn Clp_setProblemName(
        model: *mut Clp_Simplex,
        maxNumberCharacters: ::std::os::raw::c_int,
        array: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Number of iterations"]
    #[link_name = "\u{1}_Clp_numberIterations"]
    pub fn Clp_numberIterations(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Clp_setNumberIterations"]
    pub fn Clp_setNumberIterations(
        model: *mut Clp_Simplex,
        numberIterations: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Maximum number of iterations"]
    #[link_name = "\u{1}_maximumIterations"]
    pub fn maximumIterations(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Clp_setMaximumIterations"]
    pub fn Clp_setMaximumIterations(model: *mut Clp_Simplex, value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Maximum time in seconds (from when set called)"]
    #[link_name = "\u{1}_Clp_maximumSeconds"]
    pub fn Clp_maximumSeconds(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_Clp_setMaximumSeconds"]
    pub fn Clp_setMaximumSeconds(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Returns true if hit maximum iterations (or time)"]
    #[link_name = "\u{1}_Clp_hitMaximumIterations"]
    pub fn Clp_hitMaximumIterations(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Status of problem:"]
    #[doc = "0 - optimal"]
    #[doc = "1 - primal infeasible"]
    #[doc = "2 - dual infeasible"]
    #[doc = "3 - stopped on iterations etc"]
    #[doc = "4 - stopped due to errors"]
    #[link_name = "\u{1}_Clp_status"]
    pub fn Clp_status(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set problem status"]
    #[link_name = "\u{1}_Clp_setProblemStatus"]
    pub fn Clp_setProblemStatus(model: *mut Clp_Simplex, problemStatus: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Secondary status of problem - may get extended"]
    #[doc = "0 - none"]
    #[doc = "1 - primal infeasible because dual limit reached"]
    #[doc = "2 - scaled problem optimal - unscaled has primal infeasibilities"]
    #[doc = "3 - scaled problem optimal - unscaled has dual infeasibilities"]
    #[doc = "4 - scaled problem optimal - unscaled has both dual and primal infeasibilities"]
    #[link_name = "\u{1}_Clp_secondaryStatus"]
    pub fn Clp_secondaryStatus(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Clp_setSecondaryStatus"]
    pub fn Clp_setSecondaryStatus(model: *mut Clp_Simplex, status: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Direction of optimization (1 - minimize, -1 - maximize, 0 - ignore"]
    #[link_name = "\u{1}_Clp_optimizationDirection"]
    pub fn Clp_optimizationDirection(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_Clp_setOptimizationDirection"]
    pub fn Clp_setOptimizationDirection(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Primal row solution"]
    #[link_name = "\u{1}_Clp_primalRowSolution"]
    pub fn Clp_primalRowSolution(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Primal column solution"]
    #[link_name = "\u{1}_Clp_primalColumnSolution"]
    pub fn Clp_primalColumnSolution(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Dual row solution"]
    #[link_name = "\u{1}_Clp_dualRowSolution"]
    pub fn Clp_dualRowSolution(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Reduced costs"]
    #[link_name = "\u{1}_Clp_dualColumnSolution"]
    pub fn Clp_dualColumnSolution(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Row lower"]
    #[link_name = "\u{1}_Clp_rowLower"]
    pub fn Clp_rowLower(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Row upper"]
    #[link_name = "\u{1}_Clp_rowUpper"]
    pub fn Clp_rowUpper(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Objective"]
    #[link_name = "\u{1}_Clp_objective"]
    pub fn Clp_objective(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Column Lower"]
    #[link_name = "\u{1}_Clp_columnLower"]
    pub fn Clp_columnLower(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Column Upper"]
    #[link_name = "\u{1}_Clp_columnUpper"]
    pub fn Clp_columnUpper(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Number of elements in matrix"]
    #[link_name = "\u{1}_Clp_getNumElements"]
    pub fn Clp_getNumElements(model: *mut Clp_Simplex) -> CoinBigIndex;
}
extern "C" {
    #[link_name = "\u{1}_Clp_getVectorStarts"]
    pub fn Clp_getVectorStarts(model: *mut Clp_Simplex) -> *const CoinBigIndex;
}
extern "C" {
    #[link_name = "\u{1}_Clp_getIndices"]
    pub fn Clp_getIndices(model: *mut Clp_Simplex) -> *const ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Clp_getVectorLengths"]
    pub fn Clp_getVectorLengths(model: *mut Clp_Simplex) -> *const ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Clp_getElements"]
    pub fn Clp_getElements(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Objective value"]
    #[link_name = "\u{1}_Clp_objectiveValue"]
    pub fn Clp_objectiveValue(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[doc = " Integer information"]
    #[link_name = "\u{1}_Clp_integerInformation"]
    pub fn Clp_integerInformation(model: *mut Clp_Simplex) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Gives Infeasibility ray."]
    #[doc = ""]
    #[doc = " Use Clp_freeRay to free the returned array."]
    #[doc = ""]
    #[doc = " @return infeasibility ray, or NULL returned if none/wrong."]
    #[link_name = "\u{1}_Clp_infeasibilityRay"]
    pub fn Clp_infeasibilityRay(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Gives ray in which the problem is unbounded."]
    #[doc = ""]
    #[doc = " Use Clp_freeRay to free the returned array."]
    #[doc = ""]
    #[doc = " @return unbounded ray, or NULL returned if none/wrong."]
    #[link_name = "\u{1}_Clp_unboundedRay"]
    pub fn Clp_unboundedRay(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Frees a infeasibility or unbounded ray."]
    #[link_name = "\u{1}_Clp_freeRay"]
    pub fn Clp_freeRay(model: *mut Clp_Simplex, ray: *mut f64);
}
extern "C" {
    #[doc = " See if status array exists (partly for OsiClp)"]
    #[link_name = "\u{1}_Clp_statusExists"]
    pub fn Clp_statusExists(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return address of status array (char[numberRows+numberColumns])"]
    #[link_name = "\u{1}_Clp_statusArray"]
    pub fn Clp_statusArray(model: *mut Clp_Simplex) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " Copy in status vector"]
    #[link_name = "\u{1}_Clp_copyinStatus"]
    pub fn Clp_copyinStatus(model: *mut Clp_Simplex, statusArray: *const ::std::os::raw::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}_Clp_getColumnStatus"]
    pub fn Clp_getColumnStatus(
        model: *mut Clp_Simplex,
        sequence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Clp_getRowStatus"]
    pub fn Clp_getRowStatus(
        model: *mut Clp_Simplex,
        sequence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Clp_setColumnStatus"]
    pub fn Clp_setColumnStatus(
        model: *mut Clp_Simplex,
        sequence: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_Clp_setRowStatus"]
    pub fn Clp_setRowStatus(
        model: *mut Clp_Simplex,
        sequence: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " User pointer for whatever reason"]
    #[link_name = "\u{1}_Clp_setUserPointer"]
    pub fn Clp_setUserPointer(model: *mut Clp_Simplex, pointer: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_Clp_getUserPointer"]
    pub fn Clp_getUserPointer(model: *mut Clp_Simplex) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Pass in Callback function."]
    #[doc = "Message numbers up to 1000000 are Clp, Coin ones have 1000000 added"]
    #[link_name = "\u{1}_Clp_registerCallBack"]
    pub fn Clp_registerCallBack(model: *mut Clp_Simplex, userCallBack: clp_callback);
}
extern "C" {
    #[doc = " Unset Callback function"]
    #[link_name = "\u{1}_Clp_clearCallBack"]
    pub fn Clp_clearCallBack(model: *mut Clp_Simplex);
}
extern "C" {
    #[doc = " Amount of print out:"]
    #[doc = "0 - none"]
    #[doc = "1 - just final"]
    #[doc = "2 - just factorizations"]
    #[doc = "3 - as 2 plus a bit more"]
    #[doc = "4 - verbose"]
    #[doc = "above that 8,16,32 etc just for selective debug"]
    #[link_name = "\u{1}_Clp_setLogLevel"]
    pub fn Clp_setLogLevel(model: *mut Clp_Simplex, value: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_Clp_logLevel"]
    pub fn Clp_logLevel(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " length of names (0 means no names0"]
    #[link_name = "\u{1}_Clp_lengthNames"]
    pub fn Clp_lengthNames(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fill in array (at least lengthNames+1 long) with a row name"]
    #[link_name = "\u{1}_Clp_rowName"]
    pub fn Clp_rowName(
        model: *mut Clp_Simplex,
        iRow: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Fill in array (at least lengthNames+1 long) with a column name"]
    #[link_name = "\u{1}_Clp_columnName"]
    pub fn Clp_columnName(
        model: *mut Clp_Simplex,
        iColumn: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Set row name - Nice if they are short - 8 chars or less I think"]
    #[link_name = "\u{1}_Clp_setRowName"]
    pub fn Clp_setRowName(
        model: *mut Clp_Simplex,
        iRow: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Set column name - Nice if they are short - 8 chars or less I think"]
    #[link_name = "\u{1}_Clp_setColumnName"]
    pub fn Clp_setColumnName(
        model: *mut Clp_Simplex,
        iColumn: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " General solve algorithm which can do presolve."]
    #[doc = "See  ClpSolve.hpp for options"]
    #[link_name = "\u{1}_Clp_initialSolve"]
    pub fn Clp_initialSolve(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pass solve options. (Exception to direct analogue rule)"]
    #[link_name = "\u{1}_Clp_initialSolveWithOptions"]
    pub fn Clp_initialSolveWithOptions(
        model: *mut Clp_Simplex,
        arg1: *mut Clp_Solve,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dual initial solve"]
    #[link_name = "\u{1}_Clp_initialDualSolve"]
    pub fn Clp_initialDualSolve(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Primal initial solve"]
    #[link_name = "\u{1}_Clp_initialPrimalSolve"]
    pub fn Clp_initialPrimalSolve(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Barrier initial solve"]
    #[link_name = "\u{1}_Clp_initialBarrierSolve"]
    pub fn Clp_initialBarrierSolve(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Barrier initial solve, no crossover"]
    #[link_name = "\u{1}_Clp_initialBarrierNoCrossSolve"]
    pub fn Clp_initialBarrierNoCrossSolve(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dual algorithm - see ClpSimplexDual.hpp for method"]
    #[link_name = "\u{1}_Clp_dual"]
    pub fn Clp_dual(
        model: *mut Clp_Simplex,
        ifValuesPass: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Primal algorithm - see ClpSimplexPrimal.hpp for method"]
    #[link_name = "\u{1}_Clp_primal"]
    pub fn Clp_primal(
        model: *mut Clp_Simplex,
        ifValuesPass: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Solve the problem with the idiot code"]
    #[link_name = "\u{1}_Clp_idiot"]
    pub fn Clp_idiot(model: *mut Clp_Simplex, tryhard: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Sets or unsets scaling, 0 -off, 1 equilibrium, 2 geometric, 3, auto, 4 dynamic(later)"]
    #[link_name = "\u{1}_Clp_scaling"]
    pub fn Clp_scaling(model: *mut Clp_Simplex, mode: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Gets scalingFlag"]
    #[link_name = "\u{1}_Clp_scalingFlag"]
    pub fn Clp_scalingFlag(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Crash - at present just aimed at dual, returns"]
    #[doc = "-2 if dual preferred and crash basis created"]
    #[doc = "-1 if dual preferred and all slack basis preferred"]
    #[doc = "0 if basis going in was not all slack"]
    #[doc = "1 if primal preferred and all slack basis preferred"]
    #[doc = "2 if primal preferred and crash basis created."]
    #[doc = ""]
    #[doc = "if gap between bounds <=\"gap\" variables can be flipped"]
    #[doc = ""]
    #[doc = "If \"pivot\" is"]
    #[doc = "0 No pivoting (so will just be choice of algorithm)"]
    #[doc = "1 Simple pivoting e.g. gub"]
    #[doc = "2 Mini iterations"]
    #[link_name = "\u{1}_Clp_crash"]
    pub fn Clp_crash(
        model: *mut Clp_Simplex,
        gap: f64,
        pivot: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " If problem is primal feasible"]
    #[link_name = "\u{1}_Clp_primalFeasible"]
    pub fn Clp_primalFeasible(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " If problem is dual feasible"]
    #[link_name = "\u{1}_Clp_dualFeasible"]
    pub fn Clp_dualFeasible(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dual bound"]
    #[link_name = "\u{1}_Clp_dualBound"]
    pub fn Clp_dualBound(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_Clp_setDualBound"]
    pub fn Clp_setDualBound(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Infeasibility cost"]
    #[link_name = "\u{1}_Clp_infeasibilityCost"]
    pub fn Clp_infeasibilityCost(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_Clp_setInfeasibilityCost"]
    pub fn Clp_setInfeasibilityCost(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Perturbation:"]
    #[doc = "50  - switch on perturbation"]
    #[doc = "100 - auto perturb if takes too long (1.0e-6 largest nonzero)"]
    #[doc = "101 - we are perturbed"]
    #[doc = "102 - don\'t try perturbing again"]
    #[doc = "default is 100"]
    #[doc = "others are for playing"]
    #[link_name = "\u{1}_Clp_perturbation"]
    pub fn Clp_perturbation(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Clp_setPerturbation"]
    pub fn Clp_setPerturbation(model: *mut Clp_Simplex, value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Current (or last) algorithm"]
    #[link_name = "\u{1}_Clp_algorithm"]
    pub fn Clp_algorithm(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set algorithm"]
    #[link_name = "\u{1}_Clp_setAlgorithm"]
    pub fn Clp_setAlgorithm(model: *mut Clp_Simplex, value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Sum of dual infeasibilities"]
    #[link_name = "\u{1}_Clp_sumDualInfeasibilities"]
    pub fn Clp_sumDualInfeasibilities(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[doc = " Number of dual infeasibilities"]
    #[link_name = "\u{1}_Clp_numberDualInfeasibilities"]
    pub fn Clp_numberDualInfeasibilities(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sum of primal infeasibilities"]
    #[link_name = "\u{1}_Clp_sumPrimalInfeasibilities"]
    pub fn Clp_sumPrimalInfeasibilities(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[doc = " Number of primal infeasibilities"]
    #[link_name = "\u{1}_Clp_numberPrimalInfeasibilities"]
    pub fn Clp_numberPrimalInfeasibilities(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Save model to file, returns 0 if success.  This is designed for"]
    #[doc = "use outside algorithms so does not save iterating arrays etc."]
    #[doc = "It does not save any messaging information."]
    #[doc = "Does not save scaling values."]
    #[doc = "It does not know about all types of virtual functions."]
    #[link_name = "\u{1}_Clp_saveModel"]
    pub fn Clp_saveModel(
        model: *mut Clp_Simplex,
        fileName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Restore model from file, returns 0 if success,"]
    #[doc = "deletes current model"]
    #[link_name = "\u{1}_Clp_restoreModel"]
    pub fn Clp_restoreModel(
        model: *mut Clp_Simplex,
        fileName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Just check solution (for external use) - sets sum of"]
    #[doc = "infeasibilities etc"]
    #[link_name = "\u{1}_Clp_checkSolution"]
    pub fn Clp_checkSolution(model: *mut Clp_Simplex);
}
extern "C" {
    #[doc = " Number of rows"]
    #[link_name = "\u{1}_Clp_getNumRows"]
    pub fn Clp_getNumRows(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Number of columns"]
    #[link_name = "\u{1}_Clp_getNumCols"]
    pub fn Clp_getNumCols(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Number of iterations"]
    #[link_name = "\u{1}_Clp_getIterationCount"]
    pub fn Clp_getIterationCount(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Are there a numerical difficulties?"]
    #[link_name = "\u{1}_Clp_isAbandoned"]
    pub fn Clp_isAbandoned(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Is optimality proven?"]
    #[link_name = "\u{1}_Clp_isProvenOptimal"]
    pub fn Clp_isProvenOptimal(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Is primal infeasiblity proven?"]
    #[link_name = "\u{1}_Clp_isProvenPrimalInfeasible"]
    pub fn Clp_isProvenPrimalInfeasible(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Is dual infeasiblity proven?"]
    #[link_name = "\u{1}_Clp_isProvenDualInfeasible"]
    pub fn Clp_isProvenDualInfeasible(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Is the given primal objective limit reached?"]
    #[link_name = "\u{1}_Clp_isPrimalObjectiveLimitReached"]
    pub fn Clp_isPrimalObjectiveLimitReached(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Is the given dual objective limit reached?"]
    #[link_name = "\u{1}_Clp_isDualObjectiveLimitReached"]
    pub fn Clp_isDualObjectiveLimitReached(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Iteration limit reached?"]
    #[link_name = "\u{1}_Clp_isIterationLimitReached"]
    pub fn Clp_isIterationLimitReached(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Direction of optimization (1 - minimize, -1 - maximize, 0 - ignore"]
    #[link_name = "\u{1}_Clp_getObjSense"]
    pub fn Clp_getObjSense(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[doc = " Direction of optimization (1 - minimize, -1 - maximize, 0 - ignore"]
    #[link_name = "\u{1}_Clp_setObjSense"]
    pub fn Clp_setObjSense(model: *mut Clp_Simplex, objsen: f64);
}
extern "C" {
    #[doc = " Primal row solution"]
    #[link_name = "\u{1}_Clp_getRowActivity"]
    pub fn Clp_getRowActivity(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Primal column solution"]
    #[link_name = "\u{1}_Clp_getColSolution"]
    pub fn Clp_getColSolution(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[link_name = "\u{1}_Clp_setColSolution"]
    pub fn Clp_setColSolution(model: *mut Clp_Simplex, input: *const f64);
}
extern "C" {
    #[doc = " Dual row solution"]
    #[link_name = "\u{1}_Clp_getRowPrice"]
    pub fn Clp_getRowPrice(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Reduced costs"]
    #[link_name = "\u{1}_Clp_getReducedCost"]
    pub fn Clp_getReducedCost(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Row lower"]
    #[link_name = "\u{1}_Clp_getRowLower"]
    pub fn Clp_getRowLower(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Row upper"]
    #[link_name = "\u{1}_Clp_getRowUpper"]
    pub fn Clp_getRowUpper(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Objective"]
    #[link_name = "\u{1}_Clp_getObjCoefficients"]
    pub fn Clp_getObjCoefficients(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Column Lower"]
    #[link_name = "\u{1}_Clp_getColLower"]
    pub fn Clp_getColLower(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Column Upper"]
    #[link_name = "\u{1}_Clp_getColUpper"]
    pub fn Clp_getColUpper(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Objective value"]
    #[link_name = "\u{1}_Clp_getObjValue"]
    pub fn Clp_getObjValue(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[doc = " Print model for debugging purposes"]
    #[link_name = "\u{1}_Clp_printModel"]
    pub fn Clp_printModel(model: *mut Clp_Simplex, prefix: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_Clp_getSmallElementValue"]
    pub fn Clp_getSmallElementValue(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_Clp_setSmallElementValue"]
    pub fn Clp_setSmallElementValue(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_setSpecialOption"]
    pub fn ClpSolve_setSpecialOption(
        arg1: *mut Clp_Solve,
        which: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
        extraInfo: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_getSpecialOption"]
    pub fn ClpSolve_getSpecialOption(
        arg1: *mut Clp_Solve,
        which: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " method: (see ClpSolve::SolveType)"]
    #[doc = "0 - dual simplex"]
    #[doc = "1 - primal simplex"]
    #[doc = "2 - primal or sprint"]
    #[doc = "3 - barrier"]
    #[doc = "4 - barrier no crossover"]
    #[doc = "5 - automatic"]
    #[doc = "6 - not implemented"]
    #[doc = "-- pass extraInfo == -1 for default behavior"]
    #[link_name = "\u{1}_ClpSolve_setSolveType"]
    pub fn ClpSolve_setSolveType(
        arg1: *mut Clp_Solve,
        method: ::std::os::raw::c_int,
        extraInfo: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_getSolveType"]
    pub fn ClpSolve_getSolveType(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " amount: (see ClpSolve::PresolveType)"]
    #[doc = "0 - presolve on"]
    #[doc = "1 - presolve off"]
    #[doc = "2 - presolve number"]
    #[doc = "3 - presolve number cost"]
    #[doc = "-- pass extraInfo == -1 for default behavior"]
    #[link_name = "\u{1}_ClpSolve_setPresolveType"]
    pub fn ClpSolve_setPresolveType(
        arg1: *mut Clp_Solve,
        amount: ::std::os::raw::c_int,
        extraInfo: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_getPresolveType"]
    pub fn ClpSolve_getPresolveType(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_getPresolvePasses"]
    pub fn ClpSolve_getPresolvePasses(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_getExtraInfo"]
    pub fn ClpSolve_getExtraInfo(
        arg1: *mut Clp_Solve,
        which: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_setInfeasibleReturn"]
    pub fn ClpSolve_setInfeasibleReturn(arg1: *mut Clp_Solve, trueFalse: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_infeasibleReturn"]
    pub fn ClpSolve_infeasibleReturn(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_doDual"]
    pub fn ClpSolve_doDual(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_setDoDual"]
    pub fn ClpSolve_setDoDual(arg1: *mut Clp_Solve, doDual: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_doSingleton"]
    pub fn ClpSolve_doSingleton(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_setDoSingleton"]
    pub fn ClpSolve_setDoSingleton(arg1: *mut Clp_Solve, doSingleton: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_doDoubleton"]
    pub fn ClpSolve_doDoubleton(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_setDoDoubleton"]
    pub fn ClpSolve_setDoDoubleton(arg1: *mut Clp_Solve, doDoubleton: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_doTripleton"]
    pub fn ClpSolve_doTripleton(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_setDoTripleton"]
    pub fn ClpSolve_setDoTripleton(arg1: *mut Clp_Solve, doTripleton: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_doTighten"]
    pub fn ClpSolve_doTighten(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_setDoTighten"]
    pub fn ClpSolve_setDoTighten(arg1: *mut Clp_Solve, doTighten: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_doForcing"]
    pub fn ClpSolve_doForcing(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_setDoForcing"]
    pub fn ClpSolve_setDoForcing(arg1: *mut Clp_Solve, doForcing: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_doImpliedFree"]
    pub fn ClpSolve_doImpliedFree(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_setDoImpliedFree"]
    pub fn ClpSolve_setDoImpliedFree(arg1: *mut Clp_Solve, doImpliedFree: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_doDupcol"]
    pub fn ClpSolve_doDupcol(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_setDoDupcol"]
    pub fn ClpSolve_setDoDupcol(arg1: *mut Clp_Solve, doDupcol: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_doDuprow"]
    pub fn ClpSolve_doDuprow(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_setDoDuprow"]
    pub fn ClpSolve_setDoDuprow(arg1: *mut Clp_Solve, doDuprow: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_doSingletonColumn"]
    pub fn ClpSolve_doSingletonColumn(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_setDoSingletonColumn"]
    pub fn ClpSolve_setDoSingletonColumn(arg1: *mut Clp_Solve, doSingleton: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_presolveActions"]
    pub fn ClpSolve_presolveActions(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_setPresolveActions"]
    pub fn ClpSolve_setPresolveActions(arg1: *mut Clp_Solve, action: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_substitution"]
    pub fn ClpSolve_substitution(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ClpSolve_setSubstitution"]
    pub fn ClpSolve_setSubstitution(arg1: *mut Clp_Solve, value: ::std::os::raw::c_int);
}
